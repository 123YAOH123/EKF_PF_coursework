function [] = EKF_localization()
% EKF_LOCALIZATION with adaptive Q
% This code has been originally produced by Zhixin Zhang, Josh Bettles, and JC.
close all;
clear all;

disp('EKF program start!!')

tic;
time = 0;
endTime = 50; % second

global dt;
global localizer;
global Qsigma
global Rsigma

xEst = [0 0 0]';             % Estimated State [x y yaw]'
xGnd = xEst;                 % GroundTruth State (the yaw angle is not 
% restricted to [-pi,pi]) 
xOdom = xGnd;                % Odometry-only = Dead Reckoning 
% (model with no measurements)
P = zeros(3,3);
dt = 0.1;        % second

%% Real noises and sensor range
Qsigma = diag([0.1 0.01]).^2;   % prediction model
Rsigma = diag([0.01 0.01]).^2;  % observation model
MAX_RANGE = 1;  % Lidar range limit

%% Landmark positions

rng(43)% Random seeds
No_of_Landmarks = 10;
worldsize = 1.5;
landMarks = [];
for i = 1:No_of_Landmarks
    landMarks = [landMarks; -worldsize+2*worldsize*rand, -0.5+2*worldsize*rand];
end
% Last marks are saved in case you want to reuse them:
%save('lastlandmarks.mat', 'landMarks'); 

%% Prepare variables:
errs = [];
setup_localizer()
nSteps = ceil((endTime - time)/dt);

%% Initially "guessed" Q, same shape as Qsigma (2x2):
Qtune = diag([1 0.1]).^2;  % Could be bigger or smaller as an initial guess
Rtune = Rsigma;                     % Keep measurement noise fixed

% A factor for Q-adaptation:
alpha = 0.95;   

%% Outlier rejection:
% EKF in this application suffers from outliers,
% here we implement the simplest possible solution, if the
% change of the estimation is going to be very large, we reject
% the measurement. In principle, this feature should not be used.
max_update = 1e1;% maximum allowed change in the measurement update

%% Main Loop 
for i = 1 : nSteps
    % Get current timestamp
    time = time + dt;
    % Get the control input
    u = doControl(time);
    % we assume that the control input is affected by an unknown disturbance
    % simulated as a white noise:
    ureal = u + sqrt(Qsigma)*randn(2,1);
    % Get true position of the robot
    xGnd = xGnd + [dt*cos(xGnd(3))*ureal(1); dt*sin(xGnd(3))*ureal(1); dt*ureal(2)];
    % Simulate Observation
    % we will generate a variable z where: 
    % the first column is the measured distance to the landmark
    % the second column is the measured angle to the landmark
    % the third column is the true x-position of the landmark
    % the fourth column is the true y-position of the landmark
    z = [];
    if No_of_Landmarks > 0
        for iz=1:No_of_Landmarks
            d = norm(xGnd(1:2)' - landMarks(iz,:));
            alpha_meas = atan2(landMarks(iz,2)- xGnd(2), ...
                               landMarks(iz,1)- xGnd(1)) - xGnd(3);
            if d < MAX_RANGE
                z = [z; [max(0,d + sqrt(Rsigma(1,1))*randn), alpha_meas + sqrt(Rsigma(2,2))*randn, landMarks(iz,:) ]];
            end
        end
    end

    % The odometry position is generated by the deterministic control
    % action u:
    xOdom = xOdom + [dt*cos(xOdom(3))*u(1); dt*sin(xOdom(3))*u(1); dt*u(2)];

    %% Jacobian linearisation 
    A = [1, 0, -u(1)*sin(xEst(3));
         0, 1,  u(1)*cos(xEst(3));
         0, 0,  1];

    % as the noise is within the input, we require the linearisation of the
    % input:
    B = [cos(xEst(3)), 0;
         sin(xEst(3)), 0;
         0,            1];

    %   Covariance predict
    P = A*P*A' + B*Qtune*B'; % time evolution of the covariance

    % nonlinear evolution is the same as the odometry evolution:
    xPred = xEst + [dt*cos(xEst(3))*u(1); dt*sin(xEst(3))*u(1); dt*u(2)];
    xEst = xPred;  % We'll do incremental correction below
    %% Measurement update
    % As the measurements are independent, the measurement update is done
    % landmark by landmark

    if ~isempty(z)
        max_land = size(z,1);
        for iz = 1:max_land
            % Distance to the object and angle using current position and
            % estimated location
            r = norm(xEst(1:2)' - z(iz,3:4));
            % Estimated angle to the landmark
            alpha_pred = atan2(z(iz,4)-xEst(2), z(iz,3)-xEst(1)) - xEst(3);
            % We reject the measurement if our estimation is that we are
            % too close to the land mark. This avoids very large values in the
            % Jacobian
            if r > 0.1
                % innovation
            y = [z(iz,1) - r;
                 wrapToPi(z(iz,2) - alpha_pred)];
            % the command wrapToPi is used to indicate that comparison of
            % angles just make sense in the interval [-pi,pi], where only 0
            % means similar angles.

            % linearisation of the relationship between the states and the 
            % measurement:
            H = [ (xEst(1)-z(iz,3))/r,   (xEst(2)-z(iz,4))/r,   0;
                      (z(iz,4)-xEst(2))/(r^2), -(z(iz,3)-xEst(1))/(r^2), -1];

            %Innovation covariance
            S = H*P*H' + Rtune;
            % Kalman Gain:
            K = P*H'/S;
            % outlier rejection
            if norm(K*y) < max_update
                xEst = xEst + K*y;
                P = (eye(3)-K*H)*P;
            else
                disp(['rejected measurement at time ',num2str(time)])
            end
            end
        end
    end

    %% Q adaptation
    dx = xEst - xPred;   
    % Update Qtune 
    Qtune = alpha * Qtune + (1-alpha)*((pinv(B) * dx) * (pinv(B) * dx)')
     

    %%  Log the error
    errs = [errs, norm(xGnd(1:2)' - xEst(1:2)')];
    %xEst(3) = wrapToPi(xEst(3));
%% Plotting 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     Save Data and Plot     %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Simulation Result
    localizer.time       = [localizer.time; time];
    localizer.xGnd       = [localizer.xGnd; xGnd'];
    localizer.xOdom      = [localizer.xOdom; xOdom'];
    localizer.xEst       = [localizer.xEst; xEst'];
    localizer.u          = [localizer.u; u'];

    % animation (remove some flames)
    if rem(i,10)==0
        hold off;
        plot(localizer.xGnd(:,1),localizer.xGnd(:,2),'.b'); hold on;
        if No_of_Landmarks > 0
            plot(landMarks(:,1),landMarks(:,2),'pk','MarkerSize',10); hold on;
        end
        if ~isempty(z)
            for iz=1:max_land
                ray=[xGnd(1:2)'; z(iz,3:4)];
                plot(ray(:,1),ray(:,2),'-r'); hold on;
            end
        end
        plot(localizer.xOdom(:,1),localizer.xOdom(:,2),'.k'); hold on;
        plot(localizer.xEst(:,1),localizer.xEst(:,2),'.r'); hold on;
        axis equal; grid on;
        drawnow;
    end
    pause(0.01)
end

%% end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%    END    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% draw the final results of localizer, compared to odometry & ground truth
drawResults(localizer);

toc
disp(['Sum of squared errors = ', num2str(sum(errs.^2))]);

figure(2)
plot(0.1:dt:endTime, errs)
xlabel("time (s)")
ylabel("Position error (m)")
end

%% Other functions
% degree to radian
function radian = toRadian(degree)
    radian = degree/180*pi;
end

function []=drawResults(localizer)
%Plot Result
    figure(1);
    hold off;
    x = [ localizer.xGnd(:,1:2) localizer.xEst(:,1:2)];
    set(gca, 'fontsize', 12, 'fontname', 'times');
    plot(x(:,1), x(:,2),'-.b','linewidth', 2); hold on;
    plot(x(:,3), x(:,4),'-r','linewidth', 1); hold on;
    plot(localizer.xOdom(:,1), localizer.xOdom(:,2),'--k','linewidth', 2); hold on;
    title('Localization Result', 'fontsize', 12, 'fontname', 'times');
    xlabel('X (m)', 'fontsize', 12, 'fontname', 'times');
    ylabel('Y (m)', 'fontsize', 12, 'fontname', 'times');
    legend('Ground Truth','Extended Kalman Filter','Odometry Only');
    grid on; axis equal;
end

function [ u ] = doControl( time )
    % The input has been designed increase smoothly until it achieves the
    % steady state values below.
    %Calc Input Parameter
    T=10;       % [sec]
    V=0.1;      % [m/s]
    yawrate = 5;% [deg/s]
    u =[ V*(1-exp(-time/T)), toRadian(yawrate)*(1-exp(-time/T)) ]';
end

function setup_localizer()
    global localizer;
    localizer.time  = [];
    localizer.xEst  = [];
    localizer.xGnd  = [];
    localizer.xOdom = [];
    localizer.z     = [];
    localizer.PEst  = [];
    localizer.u     = [];
end
