function [] = EKF_localization()
% EKF-SLAM for a single unknown landmark and konwn landmarks
% Modified from the original EKF code(originally produced by Zhixin Zhang, Josh Bettles, and JC., modified by Han YAO).
% Version: 15 Mar 2025 

%% initialization
close all;
clear all;

disp('EKF SLAM program start!!')

tic;
time = 0;
endTime = 100; % seconds

global dt;
global localizer;
global Qsigma;
global Rsigma;


xEst = [0; 0; 0];   % Estimated State [x y yaw]'
xGnd = xEst;       % GroundTruth State (the yaw angle is not 
% restricted to [-pi,pi])
xOdom = xGnd;      % Odometry-only = Dead Reckoning 
% (model with no measurements)
P = zeros(3,3);    % initial covariance (3x3)
dt = 0.1; % second

%% real noises and sensor range 
Qsigma = diag([0.1, 0.01]).^2;  % prediction model
Rsigma = diag([0.01, 0.01]).^2; % observation noise
MAX_RANGE = 1; % longest lidar observation confined

%% landmark positions (1 unknown landmark only)
%rng(43); % random seed
num_known_landmarks = 10;
No_of_Landmarks = 1 + num_known_landmarks;   % first landmark is unknown    
worldsize = 1.5; 
landMarks = [];
for i = 1:No_of_Landmarks
    landMarks = [landMarks; -worldsize + 2*worldsize*rand, -0.5 + 2*worldsize*rand];
end
% Last marks are saved in case you want to reuse them:
%save('lastlandmarks.mat', 'landMarks'); 
%rng('shuffle'); 

%% initialisation of variables:
errs = [];
landmark_errs = []; 

setup_localizer();
nSteps = ceil((endTime - time)/dt);

localizer.landmarkTrue = landMarks(1,:); % For plotting

%% Suggested noises 
Qtune = Qsigma;   %defaul option Qtune=Qsigma
Rtune = Rsigma; %defaul option Rtune=Rsigma

%% Outlier rejection:
% EKF in this application suffers from outliers,
% here we implement the simplest possible solution, if the
% change of the estimation is going to be very large, we reject
% the measurement. In principle, this feature should not be used.
max_update = 1e1; % maximum allowed change in the measurement update

%% Flag indicating whether landmark has been augmented into state
hasLandmark = false; %% non-augmented initially
%% Main Loop 
for i = 1:nSteps
    % Get current timestamp
    time = time + dt;
    % Get the control input
    u = doControl(time);
    % we assume that the control input is affected by an unknown disturbance
    % simulated as a white noise:

    ureal = u + sqrt(Qsigma)*randn(2,1);
    
    % True (ground) state update (nonlinear motion model)
    xGnd = xGnd + [ dt*cos(xGnd(3))*ureal(1); dt*sin(xGnd(3))*ureal(1); dt*ureal(2)];
                
    % Simulate Observation
    % we will generate a variable z where: 
    % the first column is the measured distance to the landmark
    % the second column is the measured bearing to the landmark
    % the third column is the true x-position of the landmark
    % the fourth column is the true y-position of the landmark
    % z = [measured range, measured bearing, landmark true x, landmark true y]
    z = [];
    % the first landmark is unknown, which is always the first row of z
    if No_of_Landmarks > 0
        d = norm(xGnd(1:2)' - landMarks(1,:)); % distance between unknown landmark and robot
        alpha = atan2(landMarks(1,2) - xGnd(2), landMarks(1,1) - xGnd(1)) - xGnd(3);
        if d < MAX_RANGE
             z = [z; [ max(0, d + sqrt(Rsigma(1,1))*randn), alpha + sqrt(Rsigma(2,2))*randn, landMarks(1,:) ]];
        else
             z = [z; [ NaN, NaN, landMarks(1,:) ]];
        end
        
        for iz = 2:size(landMarks,1) % known landmarks 
             d = norm(xGnd(1:2)' - landMarks(iz,:));
             alpha = atan2(landMarks(iz,2) - xGnd(2), landMarks(iz,1) - xGnd(1)) - xGnd(3);
             if d < MAX_RANGE
                  z = [z; [ max(0, d + sqrt(Rsigma(1,1))*randn), alpha + sqrt(Rsigma(2,2))*randn, landMarks(iz,:) ]];
             end
        end
    end

    % The odometry position is generated by the deterministic control action u:
    xOdom = xOdom + [ dt*cos(xOdom(3))*u(1); dt*sin(xOdom(3))*u(1); dt*u(2) ];
                  
    %% Motion (Prediction) Update
    if ~hasLandmark  
        % state is still 3*1 
        A = [ 1, 0, -u(1)*sin(xEst(3));
              0, 1,  u(1)*cos(xEst(3));
              0, 0,  1 ];
        B = [ cos(xEst(3)), 0;
              sin(xEst(3)), 0;
              0,            1 ];

        P = A*P*A' + B*Qtune*B';  % time evolution of the covariance
        % nonlinear evolution is the same as the odometry evolution:
        xEst = xEst + [dt*cos(xEst(3))*u(1); dt*sin(xEst(3))*u(1); dt*u(2)];

    else
        % state extended: [x; y; theta; m_x; m_y]
        % update only the part of robot, estimated landmark position remain
        % unchange
        A_r = [ 1, 0, -u(1)*sin(xEst(3));
                0, 1,  u(1)*cos(xEst(3));
                0, 0,  1 ];
        % create entended jacobian (5x5)
        A_full = [ A_r,           zeros(3,2);
                   zeros(2,3),    eye(2) ];
        B = [ cos(xEst(3)), 0;
              sin(xEst(3)), 0;
              0,            1 ];
        Q_ = B * Qtune * B';
        Q_full = [ Q_,           zeros(3,2);
                   zeros(2,3),   zeros(2,2) ];
        % robot update only
        xEst(1:3) = xEst(1:3) + [ dt*cos(xEst(3))*u(1);
                                  dt*sin(xEst(3))*u(1);
                                  dt*u(2) ];
        % update full state covariance
        P = A_full * P * A_full' + Q_full;
    end
    
    %% Augmentation
    if ~hasLandmark && ~isnan(z(1,1))
        
        % unknown landmark measurement
        d_meas = z(1,1); % distance
        bearing_meas = z(1,2); % orientation

        % initialise state of unknown landmark
        m_x = xEst(1) + d_meas * cos(xEst(3) + bearing_meas);
        m_y = xEst(2) + d_meas * sin(xEst(3) + bearing_meas);

        % Jacobians for augmentation:
        % G_v: derivative of landmark position w.r.t. robot state (2x3)
        G_v = [ 1, 0, -d_meas * sin(xEst(3) + bearing_meas);
                0, 1,  d_meas * cos(xEst(3) + bearing_meas) ];
        % G_z: derivative of landmark position w.r.t. measurement (2x2)
        G_z = [ cos(xEst(3) + bearing_meas), -d_meas*sin(xEst(3) + bearing_meas);
                sin(xEst(3) + bearing_meas),  d_meas*cos(xEst(3) + bearing_meas) ];

        % Augment landmark covariance:
        P_mm = G_v * P * G_v' + G_z * Rtune * G_z'; % P here is the current 3x3 covariance of robot state.
       % Cross-covariance between robot and landmark:
        P_xm = P * G_v';  % 3x2
        p_mx = P_xm';

        % Augment state vector and covariance matrix:
        xEst = [ xEst; m_x; m_y ];  % 5x1
        P = [ P,       P_xm;
              p_mx,   P_mm ];     % 5x5
        hasLandmark = true; % flag change
    end
    
    %% Measurement Update
    if ~isempty(z)
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if length(xEst) == 3 % unextended states, unknown landmark is not detectable yet
            if size(z,1) > 1 % if it is measuring known landmarks
                for iz = 2:size(z,1)
                    m_x_known = z(iz,3);
                    m_y_known = z(iz,4);
                    dx = m_x_known - xEst(1);
                    dy = m_y_known - xEst(2);
                    r_pred = sqrt(dx^2 + dy^2);

                    if r_pred < 1e-6 
                        r_pred = 1e-6; 
                    end

                    alpha_pred = atan2(dy, dx) - xEst(3);
                    y_innov = [z(iz,1) - r_pred;
                                wrapToPi(z(iz,2) - alpha_pred)];
                    H_known_3d = [ -dx/r_pred, -dy/r_pred, 0;
                                   dy/(r_pred^2), -dx/(r_pred^2), -1 ];
                    S = H_known_3d*P*H_known_3d' + Rtune;
                    K = P*H_known_3d'/S;
                    if norm(K*y_innov) < max_update
                        xEst = xEst + K*y_innov;
                        P = (eye(length(xEst)) - K*H_known_3d) * P;
                    else
                        disp(['Rejected measurement at time ', num2str(time)]);
                    end
                    xEst(3) = wrapToPi(xEst(3));
                end
            end
         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
        else % extended states
            if ~isnan(z(1,1)) % if unknown landmark detectable
                dx = xEst(4) - xEst(1);
                dy = xEst(5) - xEst(2);
                r_pred = sqrt(dx^2 + dy^2);
                if r_pred < 1e-6
                    r_pred = 1e-6; 
                end
                alpha_pred = atan2(dy, dx) - xEst(3);
                y_innov = [z(1,1) - r_pred;
                            wrapToPi(z(1,2) - alpha_pred)];
                H_unknown = [-dx/r_pred, -dy/r_pred, 0, dx/r_pred, dy/r_pred;
                              dy/(r_pred^2), -dx/(r_pred^2), -1, -dy/(r_pred^2), dx/(r_pred^2)];
                S = H_unknown*P*H_unknown'+Rtune;
                K = P*H_unknown'/S;
                if norm(K*y_innov) < max_update
                    xEst = xEst + K*y_innov;
                    P = (eye(length(xEst)) - K*H_unknown) * P;
                else
                    disp(['Rejected measurement at time ', num2str(time)]);
                end
                xEst(3) = wrapToPi(xEst(3));
            end
            
            if size(z,1) > 1 % if known landmark detectable
                for iz = 2:size(z,1)
                    m_x_known = z(iz,3);
                    m_y_known = z(iz,4);
                    dx = m_x_known - xEst(1);
                    dy = m_y_known - xEst(2);
                    r_pred = sqrt(dx^2 + dy^2);
                    if r_pred < 1e-6, r_pred = 1e-6; end
                    alpha_pred = atan2(dy, dx) - xEst(3);
                    y_innov = [z(iz,1) - r_pred;
                                wrapToPi(z(iz,2) - alpha_pred)];
                   
                    H_known = [-dx/r_pred, -dy/r_pred, 0, 0, 0;
                                dy/(r_pred^2), -dx/(r_pred^2), -1, 0, 0];
                    S = H_known*P*H_known' + Rtune;
                    K = P*H_known'/S;
                    if norm(K*y_innov) < max_update
                        xEst = xEst + K*y_innov;
                        P = (eye(length(xEst)) - K*H_known) * P;
                    else
                        disp(['Rejected measurement at time ', num2str(time)]);
                    end
                    xEst(3) = wrapToPi(xEst(3));
                end
            end
        end
    end
    
    % Record error (position error between ground truth and estimated robot position)
    errs = [errs, norm(xGnd(1:2)' - xEst(1:2)')];
    
    %% Record unknown landmark estimation error
    if hasLandmark
        landmark_errs = [landmark_errs, norm(xEst(4:5) - localizer.landmarkTrue')];
    else
        landmark_errs = [landmark_errs, NaN];
    end
    
%% Plotting 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     Save Data and Plot     %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % simulation result
    localizer.time = [localizer.time; time];
    localizer.xGnd = [localizer.xGnd; xGnd'];
    localizer.xOdom = [localizer.xOdom; xOdom'];
    % record xEst as 5*1
    if length(xEst) == 3
        xEst_pad = [xEst; NaN; NaN];
    else
        xEst_pad = xEst;
    end
    localizer.xEst = [localizer.xEst; xEst_pad'];
    localizer.u = [localizer.u; u'];
    if hasLandmark
        localizer.landmarkEst = [localizer.landmarkEst; xEst(4:5)'];
    end
    
   % Animation (remove some flames)
    if rem(i,10)==0 
        hold off;
        arrow = 0.5;
        plot(localizer.xGnd(:,1), localizer.xGnd(:,2), '.b'); hold on;
        if No_of_Landmarks > 0
            plot(landMarks(:,1), landMarks(:,2), 'pk', 'MarkerSize',10); hold on;
        end
        if ~isempty(z)
            for iz = 1:size(z,1)
                ray = [ xGnd(1:2)'; z(iz,3:4) ];
                plot(ray(:,1), ray(:,2), '-r'); hold on;
            end
        end
        plot(localizer.xOdom(:,1), localizer.xOdom(:,2), '.k'); hold on;
        plot(localizer.xEst(:,1), localizer.xEst(:,2), '.r'); hold on;
       % realtime estimated landmark position
        if length(xEst) == 5
            plot(xEst(4), xEst(5), 'md', 'MarkerSize',12, 'LineWidth',2); hold on;
        end
        axis equal;
        grid on;
        drawnow;
    end
    pause(0.01)
    
end
%% end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%    END    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% draw the final results of localizer, compared to odometry & ground truth
drawResults(localizer);
toc;
disp(num2str(sum(errs.^2)));

figure(2)
plot(0.1:dt:endTime, errs)
xlabel("time")
ylabel("error square")

%% Draw estimation error of unknown landmark
figure(3)
timeVec = 0.1:dt:endTime;
plot(timeVec, landmark_errs, 'LineWidth',2)
xlabel("time")
ylabel("landmark estimation error")
title("Unknown Landmark Estimation Error")
grid on;


disp(['Sum of squared robot position error: ', num2str(sum(errs.^2))]);
if any(~isnan(landmark_errs))
    disp(['Sum of squared landmark estimation error: ', num2str(nansum(landmark_errs.^2))]);
end
end

%% Other functions
% degree to radian
function radian = toRadian(degree)
    radian = degree/180*pi;
end

function [] = drawResults(localizer)
% Plot results

    figure(1);
    hold off;
    x = [ localizer.xGnd(:,1:2) localizer.xEst(:,1:2)];
    set(gca, 'fontsize', 12, 'fontname', 'times');
    plot(x(:,1), x(:,2), '-.b', 'linewidth', 2); hold on;
    plot(x(:,3), x(:,4), '-r', 'linewidth', 1); hold on;
    plot(localizer.xOdom(:,1), localizer.xOdom(:,2), '--k', 'linewidth', 2); hold on;
    % plot true landmark position
    if isfield(localizer, 'landmarkTrue') && ~isempty(localizer.landmarkTrue)
        plot(localizer.landmarkTrue(:,1), localizer.landmarkTrue(:,2), 'kp', 'MarkerSize',12, 'MarkerFaceColor','k'); hold on;
    end
    % plot estimated landmark trajectory and current unknown landmark point
    if isfield(localizer, 'landmarkEst') && ~isempty(localizer.landmarkEst)
        plot(localizer.landmarkEst(:,1), localizer.landmarkEst(:,2), '-g', 'LineWidth',2); hold on;
        plot(localizer.landmarkEst(end,1), localizer.landmarkEst(end,2), 'md', 'MarkerSize',12, 'LineWidth',2); hold on;
    end
    title('Localization Result', 'fontsize', 12, 'fontname', 'times');
    xlabel('X (m)', 'fontsize', 12, 'fontname', 'times');
    ylabel('Y (m)', 'fontsize', 12, 'fontname', 'times');
    legend('Ground Truth', 'Extended Kalman Filter', 'Odometry Only');
    grid on;
    axis equal;
end

function [ u ] = doControl( time )
    % The input has been designed increase smoothly until it achieves the
    % steady state values below.
    %Calc Input Parameter
    T = 10; % [sec]
    % [V yawrate]
    V = 0.1; % [m/s]
    yawrate = 5; % [deg/s]
    u = [ V*(1-exp(-time/T)), toRadian(yawrate)*(1-exp(-time/T)) ]';
end

function setup_localizer()
    global localizer;
    localizer.time = [];                                                       % all historical timestamps
    localizer.xEst = [];                                                       % all estimate results
    localizer.xGnd = [];                                                       % all ground true
    localizer.xOdom = [];                                                      % all odometry only results
    localizer.z = [];                                                          % 
    localizer.PEst = [];
    localizer.u = [];
    localizer.landmarkEst = [];  % estimated landmark position
    localizer.landmarkTrue = []; % true landmark position
end
