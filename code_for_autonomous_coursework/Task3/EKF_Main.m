function [] = EKF_localization()
% EKF_LOCALIZATION
% TASK for Extended Kalman Filter localization
% This code has been produced by Zhixin Zhang, Josh Bettles, and JC.
% Version 1: 6 Mar 2025
%% initialization
close all;
clear all;
 
disp('EKF program start!!')
 
tic;
time = 0;
endTime = 50; % second

global dt;
global localizer;
global Qsigma
global Rsigma

xEst=[0 0 0]';              % Estimated State [x y yaw]'
xGnd = xEst;                % GroundTruth State (the yaw angle is not 
% restricted to [-pi,pi]) 
xOdom = xGnd;               % Odometry-only = Dead Reckoning 
% (model with no measurements)
P = zeros(3,3);
dt = 2; % second

%% real noises and sensor range 
Qsigma=diag([1 0.01]);  % prediction model
Rsigma=diag([0.01 0.01]).^2;     % observation model
MAX_RANGE = 10; % longest lidar observation confined
%% landmark positions

No_of_Landmarks = 5;          
worldsize = 1.5; 
landMarks = [];
for i = 1:No_of_Landmarks
    landMarks = [landMarks; -worldsize+2*worldsize*rand, -0.5+2*worldsize*rand];
end
% Last marks are saved in case you want to reuse them:
%save('lastlandmarks.mat', 'landMarks'); 

%% initialisation of variables:
errs = [];
setup_localizer()
nSteps = ceil((endTime - time)/dt);

%% Suggested noises 
Qtune=Qsigma*(dt/0.0005);  %defaul option Qtune=Qsigma
Rtune=Rsigma;  %defaul option Rtune=Rsigma

%% Outlier rejection:
% EKF in this application suffers from outliers,
% here we implement the simplest possible solution, if the
% change of the estimation is going to be very large, we reject
% the measurement. In principle, this feature should not be used.
max_update = 1e1; % maximum allowed change in the measurement update

%% Simulink connection
model = 'robot_continuous'; % load model
set_param(model, 'FastRestart', 'on'); % 'set 'fast restart'
set_param(model, 'LoadInitialState', 'off', ...
    'SaveFinalState', 'on', ...
    'FinalStateName', 'xFinal', ...
    'SaveOperatingPoint', 'on'); % keep final state when finish

%% Main Loop 
for t = dt:dt:endTime
    %% read value from simulink
    set_param(model, 'StopTime', num2str(t));
    out = sim(model); % do simulation
    logs = out.logsout; % get dataset
    x_robot_data = logs.get('x');  
    current_Value = x_robot_data.Values.data(end-2:end); % current state value (3 elemants)

    %% 
    % Get the control input
    u=doControl(t);
    % we assume that the control input is affected by an unknown disturbance
    % simulated as a white noise:
    % ureal=u+sqrt(Qsigma)*randn(2,1);
    % Get true position of the robot
    xGnd = [current_Value(1); current_Value(2); current_Value(3)];
    % xGnd=xGnd+[dt*cos(xGnd(3))*ureal(1);dt*sin(xGnd(3))*ureal(1) ; dt*ureal(2)]; 
    %Simulate Observation
    % we will generate a variable z where: 
    % the first column is the measured distance to the landmark
    % the second column is the measured angle to the landmark
    % the third column is the true x-position of the landmark
    % the fourth column is the true y-position of the landmark
    z=[];
    if No_of_Landmarks >0
        for iz=1:length(landMarks(:,1))
            d = norm(xGnd(1:2)'-landMarks(iz,:));
            alpha = atan2(-xGnd(2)' +landMarks(iz,2), -xGnd(1)' +landMarks(iz,1)) - xGnd(3);
            if d<MAX_RANGE
                z=[z;[max(0,d+sqrt(Rsigma(1,1))*randn) alpha+sqrt(Rsigma(2,2))*randn landMarks(iz,:)]];   % add observation noise randomly
            end
        end
    end

    % The odometry position is generated by the deterministic control
    % action u:
     xOdom = xOdom+[dt*cos(xOdom(3))*u(1);dt*sin(xOdom(3))*u(1) ; dt*u(2)];

    %% Jacobian linearisation 
    A = [1, 0, -u(1)*sin(xEst(3));
         0, 1, u(1)*cos(xEst(3));
         0, 0, 1];
    
    % as the noise is within the input, we require the linearisation of the
    % input:
    B = [cos(xEst(3)), 0;
         sin(xEst(3)), 0;
         0,            1];

    P = A*P*A' + B*Qtune*B'; % time evolution of the covariance


    % nonlinear evolution is the same as the odometry evolution:
    xEst = xEst+[dt*cos(xEst(3))*u(1);dt*sin(xEst(3))*u(1) ; dt*u(2)];

    %% Measurement update
    % As the measurements are independent, the measurement update is done
    % landmark by landmark

    if ~isempty(z)
        max_land=length(z(:,1));
        for iz=1:max_land
            % Distance to the object and angle using current position and
            % estimated location
            r = norm(xEst(1:2)'- z(iz,3:4));
            % Estimated angle to the landmark
            alpha = atan2(z(iz,4)-xEst(2)', z(iz,3)-xEst(1)') - xEst(3);
            % We reject the measurement if our estimation is that we are
            % too close to the land mark. This avoids very large values in the
            % Jacobian
            if r>0.1 
            %innovation
            y = [z(iz,1) - r;...
                wrapToPi(z(iz,2) - alpha)];
            % the command wrapToPi is used to indicate that comparison of
            % angles just make sense in the interval [-pi,pi], where only 0
            % means similar angles.

            % linearisation of the relationship between the states and the 
            % measurement:
            H = [(xEst(1)-z(iz,3))/r, (xEst(2)-z(iz,4))/r, 0;...
                (z(iz,4) -xEst(2)')/(r*r), -(z(iz,3) - xEst(1)')/(r*r), -1];
            %Innovation covariance
            S = H*P*H' + Rtune;
            % Kalman Gain:
            K = P*H'/S;
            % outlier rejection
            if norm(K*y)<max_update 
                xEst = xEst + K*y;
                P = (eye(3)-K*H)*P;
            else 
                disp(['rejected measurement at time ',num2str(time)])
            end
            end
        end
    end
    errs=[errs, norm(xGnd(1:2)'-xEst(1:2)')];
    %xEst(3) = wrapToPi(xEst(3));

%% Plotting 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     Save Data and Plot     %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Simulation Result
    localizer.time=[localizer.time; time];
    localizer.xGnd=[localizer.xGnd; xGnd'];
    localizer.xOdom=[localizer.xOdom; xOdom'];
    localizer.xEst=[localizer.xEst;xEst'];
    localizer.u=[localizer.u; u'];
    
    % Animation (remove some flames)
    if rem(i,10)==0 
        hold off;
        arrow=0.5;
        plot(localizer.xGnd(:,1),localizer.xGnd(:,2),'.b');hold on;
        if No_of_Landmarks >0
            plot(landMarks(:,1),landMarks(:,2),'pk','MarkerSize',10);hold on;
        end
        if~isempty(z)
            for iz=1:max_land
                ray=[xGnd(1:2)';z(iz,3:4)];
                plot(ray(:,1),ray(:,2),'-r');hold on;
            end
        end
        plot(localizer.xOdom(:,1),localizer.xOdom(:,2),'.k');hold on;
        plot(localizer.xEst(:,1),localizer.xEst(:,2),'.r');hold on;
        axis equal;
        grid on;
        drawnow;
    end
    pause(0.01)
    
end
set_param(model, 'FastRestart', 'off'); % turn off 'fast restart'

%% end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%    END    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% draw the final results of localizer, compared to odometry & ground truth
drawResults(localizer);
toc
num2str(sum(errs.^2))
figure(2)
plot(0.1:dt:endTime,errs)
xlabel("time")
ylabel("error square")
end

%% Other functions
% degree to radian
function radian = toRadian(degree)
    radian = degree/180*pi;
end

function []=drawResults(localizer)
%Plot Result
 
    figure(1);
    hold off;
    x=[ localizer.xGnd(:,1:2) localizer.xEst(:,1:2)];
    set(gca, 'fontsize', 12, 'fontname', 'times');
    plot(x(:,1), x(:,2),'-.b','linewidth', 2); hold on;
    plot(x(:,3), x(:,4),'-r','linewidth', 1); hold on;
    plot(localizer.xOdom(:,1), localizer.xOdom(:,2),'--k','linewidth', 2); hold on;
    title('Localization Result', 'fontsize', 12, 'fontname', 'times');
    xlabel('X (m)', 'fontsize', 12, 'fontname', 'times');
    ylabel('Y (m)', 'fontsize', 12, 'fontname', 'times');
    legend('Ground Truth','Extended Kalman Filter','Odometry Only');
    grid on;
    axis equal;
end

function [ u ] = doControl( time )
    % The input has been designed increase smoothly until it achieves the
    % steady state values below.
    %Calc Input Parameter
    T=10; % [sec]
    % [V yawrate]
    V=0.1; % [m/s]
    yawrate = 5; % [deg/s]
    u =[ V*(1-exp(-time/T)) toRadian(yawrate)*(1-exp(-time/T))]';
end

function setup_localizer()
    global localizer;
    localizer.time = [];                                                       % all historical timestamps
    localizer.xEst = [];                                                       % all estimate results
    localizer.xGnd = [];                                                       % all ground true
    localizer.xOdom = [];                                                      % all odometry only results
    localizer.z = [];                                                          % 
    localizer.PEst=[];
    localizer.u=[];
end